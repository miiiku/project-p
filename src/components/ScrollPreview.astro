---
interface Props {
  wrapper: string;
  item: string;
}

const { wrapper, item } = Astro.props;
---

<scroll-preview popover="manual" data-wrapper={wrapper} data-item={item}></scroll-preview>

<script>

  class ScrollPreview extends HTMLElement {
    constructor() {
      super();

      this.shadowRoot = this.attachShadow({ mode: 'open' });
      
      this._initStyle();

      const {
        previewPopover,
        previewWrapper,
        previewImage,
        scrollbar
      } = this._initDomTree();
      
      this.previewPopover = previewPopover;
      this.previewWrapper = previewWrapper;
      this.previewImage = previewImage;
      this.scrollbar = scrollbar;

      this._initPhotos();

      this.handleKeyUpSelf = this.handleKeyUp.bind(this);
      this.handleScrollSelf = this.handleScroll.bind(this);
      this.handleScrollingSelf = this.handleScrolling.bind(this);
      this.throttleScroll = this._throttle(this.handleScrollingSelf);
    }

    _initStyle() {
      const sheet = new CSSStyleSheet();

      sheet.replaceSync(`
        .preview-wrapper {
          position: fixed;
          inset: 0;
          padding-block: 6vh;
          padding-inline: 10vw;
          background-color: white;
          transition: color 0.3s ease-in-out;
        }
        .preview-image {
          display: block;
          max-width: 100%;
          max-height: 100%;
          margin: auto;
          object-fit: cover;
        }
        .scrollbar-wrapper {
          position: fixed;
          inset-inline: 0;
          bottom: 32px;
          display: grid;
          grid-template-columns: 1fr minmax(0,800px) 1fr;
        }
        .scrollbar-inner {
          grid-column-start: 2;
          padding-inline: 12px;
          border-radius: 4px;
          background-color: color-mix(in oklab, var(--color-stone-800) 5%, transparent);
        }
        .scrollbar {
          list-style: none;
          margin: 0;
          padding: 0;
          position: relative;
          width: 100%;
          height: 88px;
          overflow-x: clip;
        }
        .scrollbar-item {
          position: absolute;
          inset-block: 0;
          margin-block: auto;
          display: block;
          width: 64px;
          height: 64px;
          cursor: pointer;
          border-radius: 4px;
          transform-origin: bottom;
          transition: transform 0.3s ease-in-out;
          overflow: hidden;
        }
        .scrollbar-img {
          display: block;
          width: 100%;
          height: 100%;
          object-fit: cover;
        }
      `);

      this.shadowRoot?.adoptedStyleSheets.push(sheet);
    }

    _initDomTree() {
      const template = `
        <div class="scroll-preview">
          <div class="preview-wrapper">
            <img class="preview-image" />
          </div>
          <div class="scrollbar-wrapper">
            <div class="scrollbar-inner">
              <ul class="scrollbar"></ul>
            </div>
          </div>
        </div>
      `;
      const templateElement = document.createElement('template');
      templateElement.innerHTML = template;
      
      const content = templateElement.content;

      const previewPopover = content.querySelector('.scroll-preview') as HTMLDivElement;
      const previewWrapper = content.querySelector('.preview-wrapper') as HTMLDivElement;
      const previewImage = content.querySelector('.preview-image') as HTMLImageElement;
      const scrollbar = content.querySelector('.scrollbar') as HTMLUListElement;

      this.shadowRoot.appendChild(content);

      return {
        previewPopover,
        previewWrapper,
        previewImage,
        scrollbar,
      }
    }

    _initPhotos() {
      const wrapper = this.dataset.wrapper;
      const item = this.dataset.item;
      const serviceTarget = document.querySelector(`.${wrapper}`) as HTMLElement;
      const photos = serviceTarget?.querySelectorAll(`.${item}`);

      this.serviceTarget = serviceTarget;
      this.photos = Array.from(photos || []).map((photo) => {
        const p: Photo = {
          src: photo.getAttribute('data-src') || '',
          name: photo.getAttribute('title') || '',
          color: photo.getAttribute('data-color') || '',
          clip: photo.getAttribute('data-clip') || '',
        };

        this._createThumbPhoto(p);

        return p;
      });
    }

    _createThumbPhoto(photo: Photo) {
      const li = document.createElement('li');
      li.classList.add('scrollbar-item');

      const img = document.createElement('img');
      img.classList.add('scrollbar-img');
      img.src = photo.clip || photo.src;
      img.alt = photo.name;

      li.appendChild(img);
      this.photoEls.push(li);
      this.scrollbar.appendChild(li);
    }
    
    popoverOpen: boolean = false;
    shadowRoot: ShadowRoot;
    photos: Photo[] = [];
    photoEls: HTMLLIElement[] = [];
    serviceTarget: HTMLElement | undefined;
    previewPopover: HTMLElement;
    previewWrapper: HTMLElement;
    previewImage: HTMLImageElement;
    scrollbar: HTMLUListElement;
    
    activeIndex: number = 0;
    blockSize: number = 64;
    blockGap: number = 12;
    scrollX: number = 0;

    handleKeyUpSelf: (e: KeyboardEvent) => void;
    handleScrollSelf: (e: WheelEvent) => void;
    handleScrollingSelf: (e: WheelEvent) => void;
    throttleScroll: (e: WheelEvent) => void;

    static getTarget(el: HTMLElement, cb: (target: HTMLElement) => boolean): HTMLElement | null {
      if (cb(el)) return el;

      if (el.parentElement) {
        return ScrollPreview.getTarget(el.parentElement, cb);
      }

      return null;
    }

    _throttle (fn: (e: WheelEvent) => void, delay = 100) {
      let lastCallTime = 0;
      return (e: WheelEvent) => {
        const now = Date.now();
        if (now - lastCallTime < delay) {
          return;
        }
        lastCallTime = now;
        fn(e);
      };
    }

    updateScrollX() {
      const { photos, blockSize, blockGap, activeIndex, scrollbar } = this;
      const photoCount = photos.length;
      const clientWidth = scrollbar.clientWidth || 0;
      const scrollWidth = (blockSize + blockGap) * photoCount + blockGap;
      const activeOffset = (blockSize + blockGap) * activeIndex + blockGap + blockSize / 2;
      const x = activeOffset - clientWidth / 2;
      this.scrollX = Math.max(0, Math.min(x, scrollWidth - clientWidth));
    }

    update() {
      const { activeIndex, photos, blockSize, blockGap, scrollX, photoEls } = this;
      
      if (!photos) return;
      
      const activePhoto = photos[activeIndex];
      
      if (!activePhoto) return;

      this.previewImage.src = activePhoto.src;
      this.previewImage.alt = activePhoto.name;
      this.previewWrapper.style.backgroundColor = activePhoto.color || '#ffffff';

      photoEls.forEach((item, index) => {
        item.style.transform = `
          translate3d(${
            index * (blockSize + blockGap) + blockGap - scrollX
          }px, 0, 0)
          scale(${activeIndex === index ? 1.26 : 1})
        `
      })
    }

    handleScrolling(e: WheelEvent) {
      const photoCount = this.photos.length;

      if (e.deltaY > 0) this.activeIndex += 1;
      if (e.deltaY < 0) this.activeIndex -= 1;

      this.activeIndex = Math.max(0, Math.min(this.activeIndex, photoCount - 1));

      this.updateScrollX();
      this.update();
    }

    handleScroll(e: WheelEvent) {
      if (!this.popoverOpen) return;
      if (Math.abs(e.deltaY) < 3) return;
      this.throttleScroll(e);
    }

    handleKeyUp(e: KeyboardEvent) {
      if (!this.popoverOpen) return;
      if (e.key === 'Escape') {
        this.hide();
      }
      if (e.key === 'ArrowLeft') {
        this.activeIndex -= 1;
        this.updateScrollX();
        this.update();
      }
      if (e.key === 'ArrowRight') {
        this.activeIndex += 1;
        this.updateScrollX();
        this.update();
      }
    }

    show (index?: number) {
      this.showPopover();
      // this.style.display = 'block';
      /** 更新下标 */
      if (index !== undefined) {
        this.activeIndex = index;
        this.updateScrollX();
        this.update();
      }
    }

    hide () {
      this.hidePopover();
      // this.style.display = 'none';
    }

    connectedCallback () {
      this.update();

      // this.style.display = 'none';

      /** 事件委托 */
      if (this.serviceTarget) {
        this.serviceTarget.addEventListener('mousedown', (e) => {
          const itemClassName = this.dataset.item || '';
          const target = e.target as HTMLElement;
          const targetItem = ScrollPreview.getTarget(target, (el) => el.classList.contains(itemClassName));
          if (!targetItem) return;
          // targetItem.style.viewTransitionName = 'focus-photo';
          // document.startViewTransition(() => {
            this.show(Number(targetItem.dataset.index));
          //   this.previewImage.style.viewTransitionName = 'focus-photo';
          //   targetItem.style.viewTransitionName = '';
          // })
        })
      }

      /** 监听显示状态 */
      this.addEventListener('toggle', (e: any) => {
        if (e.newState === 'open') {
          this.popoverOpen = true;
          document.body.style.overflow = 'hidden';
        }
        if (e.newState === 'closed') {
          this.popoverOpen = false;
          document.body.style.overflow = 'auto';
        }
      })

      document.addEventListener('keyup', this.handleKeyUpSelf);
      document.addEventListener('wheel', this.handleScrollSelf);
    }

    disconnectedCallback () {
      document.removeEventListener('keyup', this.handleKeyUpSelf);
      document.removeEventListener('wheel', this.handleScrollSelf);
    }
  }

  customElements.define('scroll-preview', ScrollPreview);
</script>